# 虽然这不是一次正经的面试仅仅是和大佬聊了聊但作为第一次go的面试我觉得还是有必要记录一下,问到的问题不会全写只会罗列出我认为比较重要的内容也算是一种复习吧。

一.channel的几种关闭方式？

这篇文章完美的回答了这个问题 https://www.jianshu.com/p/d24dfbb33781 （膜拜大佬了 ～）

简单总结一下（一定要遵循的原则：1.不要在关闭已经关闭的通道2.不要给已经关闭的通道继续发送）

1.最简单的一种方式实现一个函数用来检查通道关闭了没有
```
func IsClosed(ch <-chan T) bool {
    select {
    case <-ch:
        return true
    default:
    }
    
    return false
}
func main() {
    c := make(chan T)
    fmt.Println(IsClosed(c)) // false
    close(c)
    fmt.Println(IsClosed(c)) // true
}
```
这种函数靠select，default实现。我们可以将通道传入函数通过case来判断是否是接收通道是就说明通道已经关闭返回true如果不是就返回false说明通道没有关闭。但是这种方法只能检查一时的状态如果你的代码中调用了类似功能的方法修改了通道的状态，那么你相信这次结果必然会产生，关闭已经关闭的通道，给已经关闭的通道发送值的错误。

2.使用defer和recover来使你的数据安全的发送到通道
```
func SafeSend(ch chan T, value T) (closed bool) {
    defer func() {
        if recover() != nil {
            // the return result can be altered 
            // in a defer function call
            closed = true
        }
    }()
    
    ch <- value // panic if ch is closed
    return false // <=> closed = false; return
}
```
首先这个方式符合不在接受端关闭的原则。所以我们实现的是一个安全的发送端。如果通道没有关闭数据会安全的发送进去，并返回false。如果通道关闭那么引发一次panic，recover恢复panic并且返回true告诉你通道关闭了。

3.安全的关闭通道
```
func SafeClose(ch chan T) (justClosed bool) {
    defer func() {
        if recover() != nil {
            justClosed = false
        }
    }()
    
    // assume ch != nil here.
    close(ch) // panic if ch is closed
    return true
}
```
可以使用这个方法关闭通道，如果通道没有关闭就关闭通道并且返回true，如果通道关闭了那么就会引发panic，触发recover返回false。

4.使用sync.Once来关闭channel
```
type MyChannel struct {
    C    chan T
    once sync.Once
}

func NewMyChannel() *MyChannel {
    return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
    mc.once.Do(func(){
        close(mc.C)
    })
}
```
因为Once的关系，通道只能被关闭一次，这样就避免了多次关闭的问题。

5.使用Mutex避免多次关闭channel
```
type MyChannel struct {
    C      chan T
    closed bool
    mutex  sync.Mutex
}

func NewMyChannel() *MyChannel {
    return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
    mc.mutex.Lock()
    if !mc.closed {
        close(mc.C)
        mc.closed = true
    }
    mc.mutex.Unlock()
}

func (mc *MyChannel) IsClosed() bool {
    mc.mutex.Lock()
    defer mc.mutex.Unlock()
    return mc.closed
}
```
通关变量closed来控制锁的获取权限。

6.在一个发送端多个接收端的情况下，先用Waitgroup的Add数来控制通道的大小，然后一个发送端开始发送数据，并且设置好停止发送的条件，并在不想发送的时候停止关闭通道。多个接收端开始接收，并且每一次接收完毕就waitgroup.Done。这样做就可以确保全部接受，并且符合不在接收端关闭通道的原则。
```
package main

import (
    "time"
    "math/rand"
    "sync"
    "log"
)

func main() {
    rand.Seed(time.Now().UnixNano())
    log.SetFlags(0)
    
    // ...
    const MaxRandomNumber = 100000
    const NumReceivers = 100
    
    wgReceivers := sync.WaitGroup{}
    wgReceivers.Add(NumReceivers)
    
    // ...
    dataCh := make(chan int, 100)
    
    // the sender
    go func() {
        for {
            if value := rand.Intn(MaxRandomNumber); value == 0 {
                // the only sender can close the channel safely.
                close(dataCh)
                return
            } else {            
                dataCh <- value
            }
        }
    }()
    
    // receivers
    for i := 0; i < NumReceivers; i++ {
        go func() {
            defer wgReceivers.Done()
            
            // receive values until dataCh is closed and
            // the value buffer queue of dataCh is empty.
            for value := range dataCh {
                log.Println(value)
            }
        }()
    }
    
    wgReceivers.Wait()
}
```
7.这种是多个发送端一个接收端的情况，用一个信号通道来控制停止发送请求，由于我们不能让接收者来关闭通道，所以我们可以关闭一个额外的通道来达到停止发送的目的。由于发送者有多个所以不应该在发送端直接关闭data通道，而是在接收端接收完毕通过信号通道通知发送端停止发送。
```
package main

import (
    "time"
    "math/rand"
    "sync"
    "log"
)

func main() {
    rand.Seed(time.Now().UnixNano())
    log.SetFlags(0)
    
    // ...
    const MaxRandomNumber = 100000
    const NumSenders = 1000
    
    wgReceivers := sync.WaitGroup{}
    wgReceivers.Add(1)
    
    // ...
    dataCh := make(chan int, 100)
    stopCh := make(chan struct{})
        // stopCh is an additional signal channel.
        // Its sender is the receiver of channel dataCh.
        // Its reveivers are the senders of channel dataCh.
    
    // senders
    for i := 0; i < NumSenders; i++ {
        go func() {
            for {
                value := rand.Intn(MaxRandomNumber)
                
                select {
                case <- stopCh:
                    return
                case dataCh <- value:
                }
            }
        }()
    }
    
    // the receiver
    go func() {
        defer wgReceivers.Done()
        
        for value := range dataCh {
            if value == MaxRandomNumber-1 {
                // the receiver of the dataCh channel is
                // also the sender of the stopCh cahnnel.
                // It is safe to close the stop channel here.
                close(stopCh)
                return
            }
            
            log.Println(value)
        }
    }()
    
    // ...
    wgReceivers.Wait()
}
```
8.多个发送者多个接收者的情况

二.go垃圾回收

三.go内存管理

四.go调度器

pmg(也就是系统线程到goroutine的映射关系，当时一慌居然忘了可恶)

五.闭包








